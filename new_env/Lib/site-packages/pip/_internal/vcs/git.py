import logging
import os
import re
import subprocess
from typing import List, Optional, Tuple

# Setup logging
logger = logging.getLogger(__name__)

GIT_VERSION_REGEX = re.compile(
    r"^git version "  # Prefix.
    r"(\d+)"  # Major.
    r"\.(\d+)"  # Dot, minor.
    r"(?:\.(\d+))?"  # Optional dot, patch.
    r".*$"  # Suffix, including any pre- and post-release segments we don't care about.
)

HASH_REGEX = re.compile("^[a-fA-F0-9]{40}$")

class Git:
    name = "git"
    dirname = ".git"
    repo_name = "clone"
    schemes = (
        "git+http",
        "git+https",
        "git+ssh",
        "git+git",
        "git+file",
    )

    @staticmethod
    def get_base_rev_args(rev: str) -> List[str]:
        return [rev]

    def get_git_version(self) -> Tuple[int, ...]:
        version = self.run_command(
            ["version"],
            command_desc="git version",
            show_stdout=False,
            stdout_only=True,
        )
        match = GIT_VERSION_REGEX.match(version)
        if not match:
            logger.warning("Can't parse git version: %s", version)
            return ()
        return (int(match.group(1)), int(match.group(2)))

    @classmethod
    def get_current_branch(cls, location: str) -> Optional[str]:
        """Return the current branch, or None if HEAD isn't at a branch"""
        args = ["symbolic-ref", "-q", "HEAD"]
        output = cls.run_command(
            args,
            extra_ok_returncodes=(1,),
            show_stdout=False,
            stdout_only=True,
            cwd=location,
        )
        ref = output.strip()

        if ref.startswith("refs/heads/"):
            return ref[len("refs/heads/") :]

        return None

    @classmethod
    def get_revision_sha(cls, dest: str, rev: str) -> Tuple[Optional[str], bool]:
        """Return commit hash or None if it's not available"""
        output = cls.run_command(
            ["show-ref", rev],
            cwd=dest,
            show_stdout=False,
            stdout_only=True,
            on_returncode="ignore",
        )
        refs = {}
        for line in output.strip().split("\n"):
            line = line.rstrip("\r")
            if not line:
                continue
            try:
                ref_sha, ref_name = line.split(" ", maxsplit=2)
            except ValueError:
                raise ValueError(f"unexpected show-ref line: {line!r}")

            refs[ref_name] = ref_sha

        branch_ref = f"refs/remotes/origin/{rev}"
        sha = refs.get(branch_ref)
        return (sha, True) if sha else (None, False)

    @classmethod
    def resolve_revision(
        cls, dest: str, url: str, rev_options: str
    ) -> str:
        rev = rev_options
        sha, _ = cls.get_revision_sha(dest, rev)

        if sha is not None:
            return sha

        cls.run_command(
            make_command("fetch", "-q", url, rev_options),
            cwd=dest,
        )
        sha = cls.get_revision(dest, rev="FETCH_HEAD")

        return sha

    @classmethod
    def fetch_new(
        self, dest: str, url: str, rev_options: str
    ) -> None:
        """Fetch and update from remote"""
        logger.info("Cloning %s to %s", url, dest)
        self.run_command(
            make_command("clone", "--quiet", url, dest),
            cwd=dest,
        )
        if rev_options:
            rev_options = self.resolve_revision(dest, url, rev_options)
            self.run_command(
                make_command("checkout", "-q", rev_options),
                cwd=dest,
            )

    @classmethod
    def update(self, dest: str, url: str, rev_options: str) -> None:
        """Update from remote repository"""
        self.run_command(
            ["fetch", "-q", "--tags"],
            cwd=dest,
        )
        rev_options = self.resolve_revision(dest, url, rev_options)
        self.run_command(
            make_command("reset", "--hard", "-q", rev_options),
            cwd=dest,
        )

    @staticmethod
    def run_command(command, cwd=None, show_stdout=True, stdout_only=False):
        """Helper function to run git commands"""
        try:
            result = subprocess.run(
                command,
                cwd=cwd,
                check=True,
                stdout=subprocess.PIPE if stdout_only else None,
                stderr=subprocess.PIPE,
            )
            if show_stdout:
                print(result.stdout.decode())
            return result.stdout.decode() if stdout_only else result
        except subprocess.CalledProcessError as e:
            logger.error(f"Command failed: {e}")
            raise

    @classmethod
    def get_remote_url(cls, location: str) -> str:
        """Get the remote URL of the repository"""
        stdout = cls.run_command(
            ["config", "--get-regexp", r"remote\..*\.url"],
            cwd=location,
            show_stdout=False,
            stdout_only=True,
        )
        remotes = stdout.splitlines()
        if not remotes:
            raise ValueError("No remote found.")
        return remotes[0].split(" ")[1]

    @classmethod
    def get_repository_root(cls, location: str) -> Optional[str]:
        """Return the root directory of the Git repository"""
        try:
            result = cls.run_command(
                ["rev-parse", "--show-toplevel"],
                cwd=location,
                show_stdout=False,
                stdout_only=True,
            )
            return os.path.normpath(result.strip())
        except Exception:
            logger.debug("Git root not found.")
            return None
